$date
	Sun Nov 02 16:03:53 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_add_sub_8bit $end
$var wire 8 ! Z [7:0] $end
$var wire 1 " Overflow $end
$var wire 1 # Carryout $end
$var reg 8 $ A [7:0] $end
$var reg 1 % AddSub $end
$var reg 8 & B [7:0] $end
$var reg 1 ' Sel $end
$var reg 1 ( clk $end
$scope module DUT $end
$var wire 8 ) A [7:0] $end
$var wire 1 % AddSub $end
$var wire 8 * B [7:0] $end
$var wire 8 + H [7:0] $end
$var wire 1 ' Sel $end
$var wire 1 , carryin $end
$var wire 1 ( clk $end
$var wire 1 - over_flow $end
$var wire 1 . carryout $end
$var wire 8 / M [7:0] $end
$var wire 8 0 G [7:0] $end
$var reg 1 1 AddSubR $end
$var reg 8 2 Areg [7:0] $end
$var reg 8 3 Breg [7:0] $end
$var reg 1 # Carryout $end
$var reg 1 " Overflow $end
$var reg 1 4 SelR $end
$var reg 8 5 Z [7:0] $end
$var reg 8 6 Zreg [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx 6
bx 5
x4
bx 3
bx 2
x1
bx 0
bx /
x.
x-
x,
bx +
b1010 *
b11001 )
0(
0'
b1010 &
0%
b11001 $
x#
x"
bx !
$end
#5000
0-
b100011 /
0.
b1010 +
b11001 0
0,
01
04
b1010 3
b11001 2
1(
#10000
0(
#15000
0#
0"
b100011 !
b100011 5
b100011 6
1(
#20000
0(
1%
b1111 &
b1111 *
b101000 $
b101000 )
#25000
1.
b11001 /
b11110000 +
b101000 0
1,
11
b1111 3
b101000 2
1(
#30000
0(
#35000
1#
b11001 !
b11001 5
b11001 6
1(
#40000
0(
0%
b101 &
b101 *
1'
#45000
0.
b11110 /
b11001 0
b101 +
0,
01
14
b101 3
1(
#50000
0(
#55000
b100011 /
b11110 0
0#
b11110 !
b11110 5
b11110 6
1(
#60000
0(
1%
b11 &
b11 *
#65000
1.
b100000 /
b11111100 +
b100011 0
1,
11
b11 3
b100011 !
b100011 5
b100011 6
1(
#70000
0(
#75000
b11101 /
b100000 0
1#
b100000 !
b100000 5
b100000 6
1(
#80000
0(
