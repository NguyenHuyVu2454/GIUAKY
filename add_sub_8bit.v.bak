module add_sub_8bit_display (
    input [17:0] SW,
    input [3:0] KEY,
    output [8:0] LEDG,
    output [17:0] LEDR,
    output [0:6] HEX7, HEX6, HEX5, HEX4, HEX3, HEX2, HEX1, HEX0
);
    // Tín hiệu nội bộ
    wire [7:0] A, B;
    wire AddSub; // 0 = add, 1 = sub
    wire [7:0] Z;
    wire Overflow;

    assign A = SW[15:8];
    assign B = SW[7:0];
    assign AddSub = SW[17];

    // Hiển thị trực tiếp A, B trên LEDR
    assign LEDR[15:8] = A;
    assign LEDR[7:0] = B;
    assign LEDG[8] = Overflow;
    assign LEDG[7:0] = Z;

    // Module cộng/trừ
    add_sub_8bit uut (
        .A(A),
        .B(B),
        .Clock(~KEY[1]),  // Nhấn KEY[1] để thực hiện phép toán
        .Reset(~KEY[0]),  // Nhấn KEY[0] để reset
        .AddSub(AddSub),
        .Z(Z),
        .Overflow(Overflow)
    );

    // Hiển thị lên LED 7 đoạn
    hex_ssd H7 (A[7:4], HEX7);
    hex_ssd H6 (A[3:0], HEX6);
    hex_ssd H5 (B[7:4], HEX5);
    hex_ssd H4 (B[3:0], HEX4);
    hex_ssd H1 (Z[7:4], HEX1);
    hex_ssd H0 (Z[3:0], HEX0);

    // HEX3, HEX2 không dùng
    assign HEX3 = 7'b1111111;
    assign HEX2 = 7'b1111111;

endmodule


//============================================================
// 8-bit add/sub module
//============================================================
module add_sub_8bit (
    input [7:0] A, B,
    input Clock, Reset, AddSub,
    output [7:0] Z,
    output Overflow
);
    reg [7:0] Areg, Breg, Zreg;
    reg AddSubR;
    reg Overflow;
    wire [7:0] H, M;
    wire carryout, over_flow;

    // Thực hiện đảo bit B nếu là phép trừ
    assign H = Breg ^ {8{AddSubR}};

    // Bộ cộng
    adder8 nbit_adder (
        .carryin(AddSubR),
        .X(Areg),
        .Y(H),
        .S(M),
        .carryout(carryout)
    );

    // Overflow detection (chuẩn cho số có dấu)
    assign over_flow = (Areg[7] & H[7] & ~M[7]) | (~Areg[7] & ~H[7] & M[7]);

    assign Z = Zreg;

    always @(posedge Clock or posedge Reset) begin
        if (Reset) begin
            Areg <= 0;
            Breg <= 0;
            Zreg <= 0;
            AddSubR <= 0;
            Overflow <= 0;
        end else begin
            Areg <= A;
            Breg <= B;
            Zreg <= M;
            AddSubR <= AddSub;
            Overflow <= over_flow;
        end
    end
endmodule


//============================================================
// 8-bit adder
//============================================================
module adder8 (carryin, X, Y, S, carryout);
    input [7:0] X, Y;
    input carryin;
    output [7:0] S;
    output carryout;

    assign {carryout, S} = X + Y + carryin;
endmodule


//============================================================
// 7-segment decoder
//============================================================
module hex_ssd (BIN, SSD);
    input [3:0] BIN;
    output reg [0:6] SSD;

    always @(*) begin
        case (BIN)
            4'h0: SSD = 7'b0000001;
            4'h1: SSD = 7'b1001111;
            4'h2: SSD = 7'b0010010;
            4'h3: SSD = 7'b0000110;
            4'h4: SSD = 7'b1001100;
            4'h5: SSD = 7'b0100100;
            4'h6: SSD = 7'b0100000;
            4'h7: SSD = 7'b0001111;
            4'h8: SSD = 7'b0000000;
            4'h9: SSD = 7'b0000100;
            4'hA: SSD = 7'b0001000;
            4'hB: SSD = 7'b1100000;
            4'hC: SSD = 7'b0110001;
            4'hD: SSD = 7'b1000010;
            4'hE: SSD = 7'b0110000;
            4'hF: SSD = 7'b0111000;
            default: SSD = 7'b1111111;
        endcase
    end
endmodule
